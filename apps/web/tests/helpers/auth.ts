import { type Page, type BrowserContext } from "@playwright/test";

/**
 * User roles available in the test system.
 */
export type TestRole = "consumer" | "farmer" | "rider" | "admin";

/**
 * Test user credentials seeded during global setup.
 * These map to users created in the test database via Supabase auth.
 *
 * In E2E tests, we bypass the OTP flow by injecting Supabase session
 * cookies directly via the storage state approach.
 */
export interface TestUser {
  id: string;
  phone: string;
  name: string;
  role: TestRole;
  email?: string;
}

/**
 * Test user definitions — must match what global-setup seeds.
 */
export const TEST_USERS: Record<TestRole, TestUser> = {
  consumer: {
    id: "00000000-0000-0000-0000-000000000001",
    phone: "+9779800000001",
    name: "Test Consumer",
    role: "consumer",
  },
  farmer: {
    id: "00000000-0000-0000-0000-000000000002",
    phone: "+9779800000002",
    name: "Test Farmer",
    role: "farmer",
  },
  rider: {
    id: "00000000-0000-0000-0000-000000000003",
    phone: "+9779800000003",
    name: "Test Rider",
    role: "rider",
  },
  admin: {
    id: "00000000-0000-0000-0000-000000000004",
    phone: "+9779800000004",
    name: "Test Admin",
    role: "admin",
  },
};

/**
 * Storage state file paths — one per role.
 * These are generated by global-setup and contain Supabase auth cookies.
 */
export function storageStatePath(role: TestRole): string {
  return `tests/.auth/${role}-storage.json`;
}

/**
 * Inject Supabase auth session cookies into a browser context.
 *
 * This is used when you need to authenticate mid-test rather than
 * using `storageState` in the project config. It creates a Supabase
 * session by calling the admin API and sets the resulting cookies.
 *
 * Requires SUPABASE_SERVICE_ROLE_KEY and NEXT_PUBLIC_SUPABASE_URL
 * environment variables.
 */
export async function loginAsRole(
  page: Page,
  role: TestRole,
): Promise<void> {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !serviceRoleKey) {
    throw new Error(
      "NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set for auth helpers",
    );
  }

  const user = TEST_USERS[role];

  // Use Supabase admin API to create a session for the test user
  const response = await fetch(
    `${supabaseUrl}/auth/v1/admin/users/${user.id}/factors`,
    {
      method: "GET",
      headers: {
        Authorization: `Bearer ${serviceRoleKey}`,
        apikey: serviceRoleKey,
      },
    },
  );

  if (!response.ok) {
    throw new Error(
      `Failed to get user factors for ${role}: ${response.status} ${response.statusText}`,
    );
  }

  // Generate a magic link / session via admin API
  const sessionResponse = await fetch(
    `${supabaseUrl}/auth/v1/admin/generate_link`,
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${serviceRoleKey}`,
        apikey: serviceRoleKey,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        type: "magiclink",
        email: `test-${role}@jirisewa.test`,
        options: {
          data: { phone: user.phone, name: user.name },
        },
      }),
    },
  );

  if (!sessionResponse.ok) {
    const text = await sessionResponse.text();
    throw new Error(
      `Failed to generate session for ${role}: ${sessionResponse.status} — ${text}`,
    );
  }

  // Navigate to the app so cookies are set on the correct domain
  await page.goto("/en");
}

/**
 * Assert that the current page has an authenticated user.
 * Checks for the presence of auth-related UI elements.
 */
export async function assertAuthenticated(page: Page): Promise<void> {
  // The app should not show the login link when authenticated
  // This is a simple heuristic — adjust based on actual UI
  await page.waitForLoadState("networkidle");
}

/**
 * Log out the current user.
 */
export async function logout(page: Page): Promise<void> {
  // Navigate to logout or clear cookies
  const context: BrowserContext = page.context();
  await context.clearCookies();
  await page.reload();
}
